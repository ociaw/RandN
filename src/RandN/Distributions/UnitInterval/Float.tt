<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ output extension=".cs" #>
<#
var parameters = new (Type type, Type unsigned, String floatSuffix, String unsignedSuffix, Int32 fractionBits)[]
{
    (typeof(Single), typeof(UInt32), "f", "u", 23),
    (typeof(Double), typeof(UInt64), "d", "ul", 52),
};
#>
using System;
using RandN.Implementation;

/*** This file is auto generated - any changes made here will be lost. Modify UnitInterval.tt instead. ***/

// The algorithms used in the ClosedOpen, OpenClosed, and Open distributions for Single and Double
// are based off of those used in the rust rand crate:
// https://github.com/rust-random/rand/blob/2c2fbd6463bb3dba492d0387f05f953bdc297d2f/src/distributions/float.rs

namespace RandN.Distributions.UnitInterval
{
<# foreach (var param in parameters)
{
    String type = param.type.Name;
    String unsigned = param.unsigned.Name;
    String floatSuffix = param.floatSuffix;
    String unsignedSuffix = param.unsignedSuffix;
    String fractionBits = param.fractionBits.ToString();
#>
    public static partial class ClosedOpen
    {
        /// <summary>
        /// A <see cref="System.<#= type #>"/> distribution over the closed-open interval [0<#= floatSuffix #>, 1<#= floatSuffix #>).
        /// </summary>
        public readonly struct <#= type #> : IPortableDistribution<System.<#= type #>>
        {
            /// <summary>
            /// Gets the instance of <see cref="<#= type #>" />.
            /// </summary>
            public static <#= type #> Instance { get; } = new();

            /// <inheritdoc />
            public System.<#= type #> Sample<TRng>(TRng rng) where TRng : notnull, IRng
            {
                // 24 or 53 bits of precision
                const Int32 floatSize = sizeof(System.<#= type #>) * 8;
                const Int32 precision = <#= fractionBits #> + 1;
                const System.<#= type #> scale = 1.0<#= floatSuffix #> / (1<#= unsignedSuffix #> << precision);

                var random = rng.Next<#= unsigned #>();
                var value = random >> (floatSize - precision);
                return scale * value;
            }

            /// <inheritdoc />
            public Boolean TrySample<TRng>(TRng rng, out System.<#= type #> result) where TRng : notnull, IRng
            {
                result = Sample(rng);
                return true;
            }
        }
    }

    public static partial class OpenClosed
    {
        /// <summary>
        /// A <see cref="System.<#= type #>"/> distribution over the open-closed interval (0<#= floatSuffix #>, 1<#= floatSuffix #>].
        /// </summary>
        public readonly struct <#= type #> : IPortableDistribution<System.<#= type #>>
        {
            /// <summary>
            /// Gets the instance of <see cref="<#= type #>" />.
            /// </summary>
            public static <#= type #> Instance { get; } = new();

            /// <inheritdoc />
            public System.<#= type #> Sample<TRng>(TRng rng) where TRng : notnull, IRng
            {
                // 24 or 53 bits of precision
                const Int32 floatSize = sizeof(System.<#= type #>) * 8;
                const Int32 precision = <#= fractionBits #> + 1;
                const System.<#= type #> scale = 1.0<#= floatSuffix #> / (1<#= unsignedSuffix #> << precision);

                var random = rng.Next<#= unsigned #>();
                var value = random >> (floatSize - precision);
                return scale * (value + 1);
            }

            /// <inheritdoc />
            public Boolean TrySample<TRng>(TRng rng, out System.<#= type #> result) where TRng : notnull, IRng
            {
                result = Sample(rng);
                return true;
            }
        }
    }

    public static partial class Closed
    {
        /// <summary>
        /// A <see cref="System.<#= type #>"/> distribution over the closed interval [0<#= floatSuffix #>, 1<#= floatSuffix #>].
        /// </summary>
        public readonly struct <#= type #> : IPortableDistribution<System.<#= type #>>
        {
            /// <summary>
            /// Gets the instance of <see cref="<#= type #>" />.
            /// </summary>
            public static <#= type #> Instance { get; } = new();

            /// <inheritdoc />
            public System.<#= type #> Sample<TRng>(TRng rng) where TRng : notnull, IRng
            {
                // 24 or 53 bits of precision
                const Int32 floatSize = sizeof(System.<#= type #>) * 8;
                const Int32 precision = <#= fractionBits #> + 1;
                const System.<#= type #> scale = (1.0<#= floatSuffix #> + FloatUtils.MachineEpsilon<#= type #>) / (1<#= unsignedSuffix #> << precision);

                var random = rng.Next<#= unsigned #>();
                var value = random >> (floatSize - precision);
                return (scale * value).ForceStandardPrecision();
            }

            /// <inheritdoc />
            public Boolean TrySample<TRng>(TRng rng, out System.<#= type #> result) where TRng : notnull, IRng
            {
                result = Sample(rng);
                return true;
            }
        }
    }

    public static partial class Open
    {
        /// <summary>
        /// A <see cref="System.<#= type #>"/> distribution over the open interval (0<#= floatSuffix #>, 1<#= floatSuffix #>).
        /// </summary>
        public readonly struct <#= type #> : IPortableDistribution<System.<#= type #>>
        {
            /// <summary>
            /// Gets the instance of <see cref="<#= type #>" />.
            /// </summary>
            public static <#= type #> Instance { get; } = new();

            /// <inheritdoc />
            public System.<#= type #> Sample<TRng>(TRng rng) where TRng : notnull, IRng
            {
                // 23 or 52 bits of precision
                const Int32 floatSize = sizeof(System.<#= type #>) * 8;
                const Int32 precision = <#= fractionBits #>;

                var random = rng.Next<#= unsigned #>();
                var value = random >> (floatSize - precision);
                return value.IntoFloatWithExponent(0) - (1.0<#= floatSuffix #> - FloatUtils.MachineEpsilon<#= type #> / 2.0<#= floatSuffix #>);
            }

            /// <inheritdoc />
            public Boolean TrySample<TRng>(TRng rng, out System.<#= type #> result) where TRng : notnull, IRng
            {
                result = Sample(rng);
                return true;
            }
        }
    }
<#
}
#>
}
