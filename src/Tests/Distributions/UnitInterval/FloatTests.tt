<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ output extension=".cs" #>
<#
var parameters = new (Type type, String floatSuffix, String uintSuffix, Int32 bitsDiscarded)[]
{
    (typeof(Single), "f", "u", 32 - 23),
    (typeof(Double), "d", "ul", 64 - 52),
};
#>
using System;
using System.Collections.Generic;
using Xunit;
using RandN.Rngs;

/*** This file is auto generated - any changes made here will be lost. Modify UnitIntervalTests.tt instead. ***/
namespace RandN.Distributions.UnitInterval;

public sealed class FloatTests
{
<# foreach (var param in parameters)
{
    String type = param.type.Name;
    String floatSuffix = param.floatSuffix;
    String uintSuffix = param.uintSuffix;
    String bitsDiscarded = param.bitsDiscarded.ToString();
#>
    [Fact]
    public void <#= type #>Ranges()
    {
        var zeroRng = new StepRng(0) { Increment = 0 };
        var maxRng = new StepRng(UInt64.MaxValue) { Increment = 0 };
        Double low, high;

        var closedOpen = ClosedOpen.<#= type #>.Instance;
        low = closedOpen.Sample(zeroRng);
        high = closedOpen.Sample(maxRng);

        Assert.Equal(0, low);
        Assert.True(0 < high && high < 1);

        var openClosed = OpenClosed.<#= type #>.Instance;
        low = openClosed.Sample(zeroRng);
        high = openClosed.Sample(maxRng);

        Assert.True(0 < low && low < 1);
        Assert.Equal(1, high);

        var closed = Closed.<#= type #>.Instance;
        low = closed.Sample(zeroRng);
        high = closed.Sample(maxRng);

        Assert.Equal(0, low);
        Assert.Equal(1, high);

        var open = Open.<#= type #>.Instance;
        low = open.Sample(zeroRng);
        high = open.Sample(maxRng);

        Assert.True(0 < low && low < 1);
        Assert.True(0 < high && high < 1);
    }

    public static IEnumerable<Object[]> <#= type #>Params(Int32 seedStart)
    {
        yield return new Object [] { OpenClosed.<#= type #>.Instance, seedStart };
        yield return new Object[] { ClosedOpen.<#= type #>.Instance, seedStart + 1 };
        yield return new Object[] { Closed.<#= type #>.Instance, seedStart + 2};
        yield return new Object[] { Open.<#= type #>.Instance, seedStart + 3};
    }

    [Theory]
    [MemberData(nameof(<#= type #>Params), 900)]
    public void <#= type #>Average(IDistribution<<#= type #>> dist, UInt64 seed)
    {
        const Int32 iterations = 10_000;
        var rng = Pcg32.Create(seed, 11634580027462260723ul);

        Double mean = 0;
        for (var i = 0; i < iterations; i++)
        {
            var result = dist.Sample(rng);
            var delta = result - mean;
            mean += delta / (i + 1);
            Assert.True(0 <= result);
            Assert.True(result <= 1);
        }

        Assert.True(Statistics.WithinConfidence(popMean: 0.5, popStdDev: 0.5, mean, iterations));

        Double mean2 = 0;
        for (var i = 0; i < iterations; i++)
        {
            Assert.True(dist.TrySample(rng, out var result));
            var delta = result - mean2;
            mean2 += delta / (i + 1);
            Assert.True(0 <= result);
            Assert.True(result <= 1);
        }

        Assert.True(Statistics.WithinConfidence(popMean: 0.5, popStdDev: 0.5, mean2, iterations));
    }

    [Fact]
    public void <#= type #>NonNullable()
    {
        Assert.Throws<ArgumentNullException>(() => ClosedOpen.<#= type #>.Instance.Sample<StepRng>(null));
        Assert.Throws<ArgumentNullException>(() => OpenClosed.<#= type #>.Instance.Sample<StepRng>(null));
        Assert.Throws<ArgumentNullException>(() => Closed.<#= type #>.Instance.Sample<StepRng>(null));
        Assert.Throws<ArgumentNullException>(() => Open.<#= type #>.Instance.Sample<StepRng>(null));
    }
<#
}
#>
}
